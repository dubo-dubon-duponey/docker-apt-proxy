{
#	{$debug}
	https_port {$PORT}
	default_sni {$DOMAIN}
	admin off
	storage file_system {
		root "/certs"
	}
	auto_https disable_redirects
}

# TODO
# Possibly implement own caching mechanism: https://github.com/sillygod/cdp-cache
# Or https://github.com/sillygod/cdp-cache
# And get rid of aptutils entirely

# The frontend sets final headers, does some rewriting of ProxyAuth, and passes it to the backend
# The backend implements authentication before passing it down to the actual cacher
http://127.0.0.1:10042 {
  log {
    output stdout
    format json
    level {$LOG_LEVEL}
  }

  # https://securityheaders.com/
  header {
    X-Xss-Protection "1; mode=block"

    # clickjacking protection
    X-Frame-Options DENY

    # disable clients from sniffing the media type
    X-Content-Type-Options nosniff

    # keep referrer data off of HTTP connections
    # Referrer-Policy no-referrer-when-downgrade
    # Referrer-Policy "same-origin"
    Referrer-Policy "strict-origin-when-cross-origin"

    # enable HSTS
    Strict-Transport-Security "max-age=31536000; includeSubDomains; preload"

    # CSP
    Content-Security-Policy "default-src 'self';"

    # Signature
    Server "DuboDubonDuponey/1.0 (Caddy/2)"
  }

  basicauth bcrypt "{$REALM}" {
    {$USERNAME} {$PASSWORD}
  }

  request_header Host {http.request.header.X-Host}

  reverse_proxy http://127.0.0.1:3142 {
    # active health checking
    # XXX health does not seem to work /archive?healthcheck=internal
    health_path     /
    health_port     3142
    health_interval 60s
    health_timeout  5s
    health_status   200
    health_status   404
  }
}

# Add debian for proxy use
# XXX parameterize this
https://{$DOMAIN} https://*.debian.org {
	tls {$TLS} {
    client_auth {
      mode {$MTLS_MODE}
      # Technically could/should be a different root cert
      # Ideally, a separate caddy would be in charge of delivering client certs on demand maybe against credentials?
      # Of course that would downgrade the cert auth to that of the credentials then... So, for now, keep it manual / out of band
      trusted_ca_cert_file "/certs/pki/authorities/local/root.crt"
    }
	}

  # Remove dupe entry (this is set by the backedn)
  header -Server

  # If we have a proxy auth, rewrite it into plain auth before we pass it down
  @proxy {
    header Proxy-Authorization *
  }

  handle @proxy {
    request_header Authorization {http.request.header.Proxy-Authorization}
    request_header -Proxy-Authorization
  }

  # Strip the host part so our backend accept it
  request_header X-Host {http.request.header.Host}
  request_header -Host

  # Pass it down
  reverse_proxy http://127.0.0.1:10042
}

# Healthcheck
{$HEALTHCHECK_URL} {
  respond 200 {
    body {}
    close
  }
}
